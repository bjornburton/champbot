\input cwebmac

% piruett

\nocon % omit table of contents
\datethis % print date on listing


\N{1}{1}Introduction. This is the firmware portion of the propulsion system for
our
Champbot.
It features separate thrust and steering as well as piruett turning.

This will facilitate motion by taking "thrust" and "turn" pulse-width inputs
from the Futaba RC receiver by converting them to the appropriate motor
actions.
These are from Channel 2 at A1 and channel 1 at A0, respectivily.
The action will be similar to driving an RC car or boat.
By keeping it natural, it should be easier to navigate the course than with a
skid-steer style control.

\fi

\N{1}{2}Implementation.
Both pulse-width inputs will have some dead-band to allow for full stop.

The pulse-width from the receiver is at 20 ms intervals.
The time ranges from 1000--2000 ms, including trim.
1500~ ms is the width for stopped.
The levers cover $\pm$0.4~ms and the trim covers the balance.

Math for radius...I think this is right:

Where:
t is track
r is radius
v is value
f is factor

min r is 1
max r is 127

get this value for v
[1]
[127]
[255]

r=factor*abs(127-v)


For non-zero r
Inside=(2r-t)/2r
Outside=(2r+t)/2r


Port motor pulse will be applied to ???, starboard will be at ???.
The median time will be subtracted from them for a pair of signed values
thrust and radius. The value will be scaled.

The thrust and radius will be translated to power to the
port and starboard motors. When near median the motors will be disabled.
The motors will also be disabled when there are no input pulses.
Each motor need direction and power so that's 4 signals of output.

The radius control will also be the rotate control, if thrust is zero.

Adding the two signal of input, I need more I/O than the trinket has.
So---I now have a \$10 Pro Trinket with far more capability.
It has an ATmega328.

The ATmega328 has a fancy 16 bit PWM with two comparators, Timer 1.
This has an ``Input Capture Unit'' that may be used for PWC decoding.
PWC being the type of signal from the RC receiver.
That seems like as elegant a solution I will find and it is recommended by
Atmel to use ICR ``Input Capture Register'' for this purpose.

One of the other timers will do more than fine for the two motors.

For the PWC measurement, this app note, AVR135, is helpful:
www.atmel.com/images/doc8014.pdf

In the datasheet, this section is helpful: 16.6.3

Since I have two signals, maybe the best way to use this nice feature is to
take the PWC signals into the MUX, through the comparator and into the Input
Capture Unit.

An interesting thing about this Futaba receiver is that the pulses are in
series.
The channel two's pulse is first, followed the channel one.
In fact, channel two's fall is perfectly aligned with channel one's rise.
This means that it will be possible to capture all of the pulses.

After the two pulses are captured, there's an 18~ms dead-time before the next
round.
This will provide ample time to do math and set the motor PWMs.

First pick the thrust, set for a rising edge, wait, grab the time-stamp and set
for falling edge, wait, grab the time-stamp, do modulus subtraction,
switch the MUX, set for rising, reset the ICR, wait...


Extensive use was made of the datasheet, Atmel
``Atmel-8271I-AVR- ATmega-Datasheet\_10/2014''.

\Y\B\X6:Include\X\6
\X7:Types\X\6
\X9:Prototypes\X\6
\X10:Global variables\X\par
\fi

\M{3}\PB{\.{"F\_CPU"}} is used to convey the Trinket Pro clock rate.
\Y\B\4\D$\.{F\_CPU}$ \5
\T{16000000\$U\$L}\par
\B\4\D$\.{BAUD}$ \5
\T{9600}\par
\fi

\M{4}Here are some Boolean definitions that are used.
\Y\B\4\D$\.{ON}$ \5
\T{1}\par
\B\4\D$\.{OFF}$ \5
\T{0}\par
\B\4\D$\.{SET}$ \5
\T{1}\par
\B\4\D$\.{CLEAR}$ \5
\T{0}\par
\B\4\D$\.{CH2RISE}$ \5
\T{0}\par
\B\4\D$\.{CH2FALL}$ \5
\T{1}\par
\B\4\D$\.{CH1FALL}$ \5
\T{2}\par
\fi

\M{5}Here are the calibration values.
\Y\B\4\D$\.{GAINX100}$ \5
\T{6157\$L}\par
\B\4\D$\.{OFFSET}$ \5
\T{218\$L}\par
\fi

\M{6}\B\X6:Include\X${}\E{}$\6
\8\#\&{include} \.{<avr/io.h>}\SHC{ need some port access }\6
\8\#\&{include} \.{<util/delay.h>}\SHC{ need to delay }\6
\8\#\&{include} \.{<avr/interrupt.h>}\SHC{ have need of an interrupt }\6
\8\#\&{include} \.{<avr/sleep.h>}\SHC{ have need of sleep }\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<stdint.h>}\par
\U2.\fi

\M{7}Here is a structure to keep track of the state of output things,
like motor settings.

\Y\B\4\X7:Types\X${}\E{}$\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\\{uint8\_t}\\{portOut};\6
\\{uint8\_t}\\{starboardOut};\6
\\{int32\_t}\\{thrust};\6
\\{int32\_t}\\{turn};\6
\\{uint8\_t}\\{failSafe};\SHC{ safety relay }\2\6
${}\}{}$ \&{outputStruct};\par
\A8.
\U2.\fi

\M{8}Here is a structure to keep track of the state of input things,
like servo timing.

\Y\B\4\X7:Types\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\\{uint16\_t}\\{ch2rise};\6
\\{uint16\_t}\\{ch2fall};\6
\\{uint16\_t}\\{ch1fall};\6
\\{uint16\_t}\\{ch1duration};\6
\\{uint16\_t}\\{ch2duration};\6
\\{uint8\_t}\\{edge};\2\6
${}\}{}$ \&{inputStruct};\par
\fi

\M{9}\B\X9:Prototypes\X${}\E{}$\6
\&{void} \\{ledcntl}(\\{uint8\_t}\\{state});\SHC{ LED ON and LED OFF }\6
\&{void} \\{pwcCalc}(\&{inputStruct} ${}{*});{}$\6
\&{void} \\{edgeSelect}(\&{inputStruct} ${}{*}){}$;\par
\U2.\fi

\M{10}
My lone global variable may become a function pointer.
This could let me pass arguments to the actual interrupt handlers.
This pointer gets the appropriate function attached by the \PB{\.{"ISR()"}}
function.

\Y\B\4\X10:Global variables\X${}\E{}$\6
$\&{void}({*}\\{handleIrq}){}$(\&{inputStruct} ${}{*})\K\NULL{}$;\par
\U2.\fi

\M{11}
Here is \PB{\\{main}(\,)}.
\Y\B\&{int} \\{main}(\&{void})\1\1 $\{{}$\Y\par
\fi

\M{12}
The Futaba receiver leads with channel two, rising edge, so we will start
looking for that by setting \PB{\.{"edge"}} to look for a rise on channel 2.
\Y\B\&{inputStruct} \\{input\_s} $\K$ $\{$ $.$ $\\{ch2rise}\K\T{0}$ $,$ $.$ $%
\\{ch2fall}\K\T{0}$ $,$ $.$ $\\{ch1fall}\K\T{0}$ $,$ $.$ $\\{edge}\K%
\.{CH2RISE}$ $\}$  ;\7
\&{outputStruct} \\{output\_s}; \X31:Initialize the inputs and capture mode\X%
\X28:Initialize pin outputs\X\par
\fi

\M{13}
Of course, any interrupt function requires that bit ``Global Interrupt Enable''
is set; usually done through calling sei().
\Y\B\\{sei}(\,);\6
${}\{{}$\SHC{ for test purposes }\1\6
${}\.{DDRD}\MRL{\AND{\K}}\CM(\T{1}\LL\.{DDD3}){}$;\SHC{ Clear the PD3 pin }%
\SHC{ PD3 (PCINT0 pin) is now an input }\6
${}\.{PORTD}\MRL{{\OR}{\K}}(\T{1}\LL\.{PORTD3}){}$;\SHC{ turn On the Pull-up }%
\SHC{ PD3 is now an input with pull-up enabled }\6
${}\.{EICRA}\MRL{{\OR}{\K}}(\T{1}\LL\.{ISC10}){}$;\SHC{ set INT1 to trigger on
ANY logic change }\6
${}\.{EIMSK}\MRL{{\OR}{\K}}(\T{1}\LL\.{INT1}){}$;\SHC{ Turns on INT1 }\6
\4${}\}{}$\2\par
\fi

\M{14}
Rather than burning loops, waiting the ballance of 18~ms for something to
happen, the ``sleep'' mode is used.
The specific type of sleep is `idle'.
In idle, execution stops but timers continue.
Interrupts are used to wake it.

It's important to note that an ISR procedure must be defined to allow the
program to step past the sleep statement.
\Y\B\X29:Configure to idle on sleep\X\\{ledcntl}(\.{OFF});\6
${}\\{edgeSelect}({\AND}\\{input\_s}){}$;\par
\fi

\M{15}
This is the loop that does the work. It should spend most of its time in
\PB{\\{sleep\_mode}}, comming out at each interrupt event caused by an edge.

\Y\B\&{for} ( ;  ; \,) $\{{}$\Y\par
\fi

\M{16}
Now that a loop is started, we wait in ``idle'' for the edge on the channel
selected.
\Y\B\\{sleep\_mode}(\,);\SHC{ idle }\par
\fi

\M{17}
If execution arrives here, some interrupt has woken it from sleep and some
vector has possibly run.
The pointer handleIrq will be assigned the value of the responsible function.
\Y\B\&{if} ${}(\\{handleIrq}\I\NULL{}$)\SHC{ in case it woke for some other
reason }\6
${}\{{}$\1\7
${}\\{handleIrq}({\AND}\\{input\_s});{}$\6
${}\\{handleIrq}\K\NULL{}$;\SHC{ reset so that the action cannot be repeated }\6
\4${}\}{}$\SHC{ end if handleirq }\2\par
\fi

\M{18}
Center reports about 21250, hard left, or up, with trim reports about 29100
and hard right, or down, with trim reports about 13400.
With that, the gain is 1/61.569 and offset is offset is $$-$$218.14.
\Y\B$\\{output\_s}.\\{turn}\K((\T{100\$L}*\\{input\_s}.\\{ch1duration})/%
\.{GAINX100})-\.{OFFSET};{}$\6
${}\\{output\_s}.\\{thrust}\K((\T{100\$L}*\\{input\_s}.\\{ch2duration})/%
\.{GAINX100})-\.{OFFSET}{}$;\par
\fi

\M{19}
Some protection may be a good idea, just in case it gets outside the range
of an 8 bit register it will be clamped.

\Y\B\&{if} ${}(\\{output\_s}.\\{turn}>\T{255}){}$\1\5
${}\\{output\_s}.\\{turn}\K\T{255};{}$\2\6
\&{else} \&{if} ${}(\\{output\_s}.\\{turn}<\T{0}){}$\1\5
${}\\{output\_s}.\\{turn}\K\T{0};{}$\2\6
\&{if} ${}(\\{output\_s}.\\{thrust}>\T{255}){}$\1\5
${}\\{output\_s}.\\{thrust}\K\T{255};{}$\2\6
\&{else} \&{if} ${}(\\{output\_s}.\\{thrust}<\T{0}){}$\1\5
${}\\{output\_s}.\\{thrust}\K\T{0};{}$\2\6
\&{if} ${}(\\{output\_s}.\\{turn}>\T{127\$L}){}$\1\5
\\{ledcntl}(\.{ON});\2\6
\&{else}\1\5
\\{ledcntl}(\.{OFF});\2\7
$\}{}$\SHC{ end for }\7
\&{return} \T{0};\SHC{ it's the right thing to do! }\7
$\}{}$\SHC{ end main() }\par
\fi

\M{20}
Here are the ISRs.
\Y\B\.{ISR}(\\{INT1\_vect})\1\1\2\2\6
${}\{{}$\7
\,${}\}{}$\7
\.{ISR}(\\{TIMER1\_CAPT\_vect})\1\1\2\2\6
${}\{{}$\1\7
${}\\{handleIrq}\K{\AND}\\{pwcCalc};{}$\6
\4${}\}{}$\2\par
\fi

\M{21}
This procedure computes the durations from the PWC signal edge capture values
from the Input Capture Unit.
With the levers centered the durations should be about 1.5~ms so at 16~ Mhz
the count should be near 24000.
The range should be 17600 to 30400 for 12800 counts, well within the range
of the 64 kib of the 16 bit register..


\Y\B\&{void} \\{pwcCalc}(\&{inputStruct} ${}{*}\\{input\_s}){}$\1\1 $\{{}$\Y\par
\fi

\M{22}
On the falling edges we can compute the durations using modulus subtraction
and then set the edge index for the next edge.
Channel 2 leads so that rise is first.
\Y\B\&{switch} ${}(\\{input\_s}\MG\\{edge}){}$\5
${}\{{}$\1\6
\4\&{case} \.{CH2RISE}:\5
${}\\{input\_s}\MG\\{ch2rise}\K\.{ICR1};{}$\6
${}\\{input\_s}\MG\\{edge}\K\.{CH2FALL};{}$\6
\&{break};\6
\4\&{case} \.{CH2FALL}:\5
${}\\{input\_s}\MG\\{ch2fall}\K\.{ICR1};{}$\6
${}\\{input\_s}\MG\\{ch2duration}\K\\{input\_s}\MG\\{ch2fall}-\\{input\_s}\MG%
\\{ch2rise};{}$\6
${}\\{input\_s}\MG\\{edge}\K\.{CH1FALL};{}$\6
\&{break};\6
\4\&{case} \.{CH1FALL}:\5
${}\\{input\_s}\MG\\{ch1fall}\K\.{ICR1};{}$\6
${}\\{input\_s}\MG\\{ch1duration}\K\\{input\_s}\MG\\{ch1fall}-\\{input\_s}\MG%
\\{ch2fall};{}$\6
${}\\{input\_s}\MG\\{edge}\K\.{CH2RISE};{}$\6
\4${}\}{}$\2\6
\\{edgeSelect}(\\{input\_s});\7
$\}{}$\par
\fi

\M{23}

The procedure edgeSelect configures the Input Capture unit to capture on the
expected edge type.

\Y\B\&{void} \\{edgeSelect}(\&{inputStruct} ${}{*}\\{input\_s}){}$\1\1 $\{{}$\7
\&{switch} ${}(\\{input\_s}\MG\\{edge}){}$\5
${}\{{}$\1\6
\4\&{case} \.{CH2RISE}:\SHC{ wait for rising edge on servo channel 2 }\6
${}\.{ADMUX}\MRL{{\OR}{\K}}(\T{1}\LL\.{MUX0}){}$;\SHC{ Set to mux channel 1 }\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICES1}){}$;\SHC{ Rising edge (23.3.2) }%
\6
\&{break};\6
\4\&{case} \.{CH2FALL}:\5
${}\.{ADMUX}\MRL{{\OR}{\K}}(\T{1}\LL\.{MUX0}){}$;\SHC{ Set to mux channel 1 }\6
${}\.{TCCR1B}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ICES1}){}$;\SHC{ Falling edge
(23.3.2) }\6
\&{break};\6
\4\&{case} \.{CH1FALL}:\5
${}\.{ADMUX}\MRL{\AND{\K}}\CM(\T{1}\LL\.{MUX0}){}$;\SHC{ Set to mux channel 0 }%
\6
${}\.{TCCR1B}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ICES1}){}$;\SHC{ Falling edge
(23.3.2) }\6
\4${}\}{}$\2\par
\fi

\M{24}
Since the edge has been changed, the Input Capture Flag should be cleared.
It's odd but clearing it involves writing a one to it.
\Y\B$\.{TIFR1}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICF1}){}$;\SHC{ (per 16.6.3) }\7
$\}{}$\par
\fi

\M{25}
Here is a simple procedure to flip the LED on or off.
\Y\B\&{void} \\{ledcntl}(\\{uint8\_t}\\{state})\1\1\2\2\6
${}\{{}$\1\6
${}\.{PORTB}\K\\{state}\?\.{PORTB}\OR(\T{1}\LL\.{PORTB5}):\.{PORTB}\AND\CM(%
\T{1}\LL\.{PORTB5});{}$\6
\4${}\}{}$\2\par
\fi

\M{26}

\fi

\N{1}{27}These are the supporting routines, procedures and configuration
blocks.


Here is the block that sets-up the digital I/O pins.
\fi

\M{28}\B\X28:Initialize pin outputs\X${}\E{}$\6
${}\{{}$\C{ set the led port direction; This is pin \#17 }\1\6
${}\.{DDRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{DDB5});{}$\6
\4${}\}{}$\2\par
\U12.\fi

\M{29}\B\X29:Configure to idle on sleep\X${}\E{}$\6
${}\{{}$\1\6
${}\.{SMCR}\MRL{\AND{\K}}\CM((\T{1}\LL\.{SM2})\OR(\T{1}\LL\.{SM1})\OR(\T{1}\LL%
\.{SM0}));{}$\6
\4${}\}{}$\2\par
\U14.\fi

\M{30}
To enable this interrupt, set the ACIE bit of register ACSR.
\fi

\M{31}\B\X31:Initialize the inputs and capture mode\X${}\E{}$\6
${}\{{}$\SHC{ ADCSRA – ADC Control and Status Register A }\1\6
${}\.{ADCSRA}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ADEN}){}$;\SHC{ Conn the MUX to (-)
input of comparator (sec 23.2) }\SHC{ 23.3.1 ADCSRB – ADC Control and Status
Register B }\6
${}\.{ADCSRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACME}){}$;\SHC{ Conn the MUX to (-)
input of comparator (sec 23.2) }\SHC{ 24.9.5 DIDR0 – Digital Input Disable
Register 0 }\6
${}\.{DIDR0}\MRL{{\OR}{\K}}((\T{1}\LL\.{AIN1D})\OR(\T{1}\LL\.{AIN0D})){}$;\SHC{
Disable digital inputs (sec 24.9.5) }\SHC{ 23.3.2 ACSR – Analog Comparator
Control and Status Register }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACBG}){}$;\SHC{ Connect + input to the
band-gap ref (sec 23.3.2) }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIC}){}$;\SHC{ Enable input capture mode
(sec 23.3.2) }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIS1}){}$;\SHC{ Set for both rising and
falling edge (sec 23.3.2) }\SHC{ 16.11.8 TIMSK1 – Timer/Counter1 Interrupt
Mask Register }\6
${}\.{TIMSK1}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICIE1}){}$;\SHC{ Enable input capture
interrupt (sec 16.11.8) }\SHC{ 16.11.2 TCCR1B – Timer/Counter1 Control
Register B }\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICNC1}){}$;\SHC{ Enable input capture
noise canceling (sec 16.11.2) }\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{CS10}){}$;\SHC{ No Prescale. Just count
the main clock (sec 16.11.2) }\SHC{ 24.9.1 ADMUX – ADC Multiplexer Selection
Register }\6
${}\.{ADMUX}\MRL{\AND{\K}}\CM((\T{1}\LL\.{MUX2})\OR(\T{1}\LL\.{MUX1})\OR(\T{1}%
\LL\.{MUX0})){}$;\SHC{ Set to mux channel 0 }\6
\4${}\}{}$\2\par

\U12.\fi


\inx
\fin
\con
