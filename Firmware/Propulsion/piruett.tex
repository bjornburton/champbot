\input cwebmac

% piruett

\nocon % omit table of contents
\datethis % print date on listing


\N{1}{1}Introduction. This is the firmware portion of the propulsion system,
featuring piruett turning.

This will facilitate motion by taking "thrust" and "radius" pulse-width
inputs and converting them to the appropriate motor actions.

Both pulse-width inputs will have some dead-band to allow for full stop.

The pulse-width from the receiver is at 20 ms intervals.
The time ranges from 1000--2000 ms, including trim.
1500 ms is the width for stopped.
The levers cover $\pm$0.4 ms and the trim
covers the balance.

Math for radius...I think this is right:

Where:
t is track
r is radius
v is value
f is factor

min r is 1
max r is 127

get this value for v
[1]
[127]
[255]

r=factor*abs(127-v)


For non-zero r
Inside=(2r-t)/2r
Outside=(2r+t)/2r


Port motor pulse will be applied to ???, starboard will be at ???.
The median time will be subtracted from them for a pair of signed values
thrust and radius. The value will be scaled.

The thrust and radius will be translated to power to the
port and starboard motors. When near median the motors will be disabled.
The motors will also be disabled when there are no input pulses.
Each motor need direction and power so that's 4 signals of output.

The radius control will also be the rotate control, if thrust is zero.

Adding the two signal of input, I need more I/O than the trinket has.
So---I now have a \$10 Pro Trinket with far more capability.
It has an ATmega328.

The ATmega328 has a fancy 16 bit PWM with two comparators, Timer 1.
This has an "Input Capture Unit" that may be used for PWC decoding.
That's an elegant solution



One of the other timers will do more than fine for the two motors.

For the PWC measurement, this app note, AVR135, is helpful:
www.atmel.com/images/doc8014.pdf

In the datasheet, this section is helpful: 16.6.3

Since I have two signals, maybe the best way to use this nice feature is to
take the PWC signals into the MUX, through the comparator and into the Input
Capture Unit.
First pick the thrust, set for a rising edge, wait, grab the time-stamp and set
for falling edge, wait, grab the time-stamp, do modulus subtraction, switch the
MUX, set for rising, reset the ICR, wait...




place-holder code below
==========================

Extensive use was made of the datasheet, Atmel ``Atmel-8271I-AVR-
ATmega-Datasheet\_10/2014''.
\Y\B\X4:Include\X\6
\X5:Types\X\6
\X6:Prototypes\X\par
\fi

\M{2}\PB{\.{"F\_CPU"}} is used to convey the Trinket Pro clock rate.
\Y\B\4\D$\.{F\_CPU}$ \5
\T{16000000\$U\$L}\par
\fi

\M{3}Here are some Boolean definitions that are used.
\Y\B\4\D$\.{ON}$ \5
\T{1}\par
\B\4\D$\.{OFF}$ \5
\T{0}\par
\B\4\D$\.{SET}$ \5
\T{1}\par
\B\4\D$\.{CLEAR}$ \5
\T{0}\par
\fi

\M{4}\B\X4:Include\X${}\E{}$\6
\8\#\&{include} \.{<avr/io.h>}\SHC{ need some port access }\6
\8\#\&{include} \.{<util/delay.h>}\SHC{ need to delay }\6
\8\#\&{include} \.{<avr/interrupt.h>}\SHC{ have need of an interrupt }\6
\8\#\&{include} \.{<avr/sleep.h>}\SHC{ have need of sleep }\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<stdint.h>}\par
\U1.\fi

\M{5}Here is a structure to keep track of the state of things.

\Y\B\4\X5:Types\X${}\E{}$\6
\&{typedef} \&{struct} ${}\{{}$\1\6
\\{uint8\_t}\\{portOut};\SHC{ }\6
\\{uint8\_t}\\{starOut};\SHC{ }\6
\\{uint16\_t}\\{thrust};\SHC{ }\6
\\{uint16\_t}\\{radius};\SHC{ }\2\6
${}\}{}$ \&{statestruct};\par
\U1.\fi

\M{6}\B\X6:Prototypes\X${}\E{}$\6
\&{void} \\{ledcntl}(\\{uint8\_t}\\{state});\SHC{ LED ON and LED OFF }\par
\U1.\fi

\M{7}
My lone global variable is a function pointer.
This lets me pass arguments to the actual interrupt handlers.
This pointer gets the appropriate function attached by the \PB{\.{"ISR()"}}
function.




\fi

\M{8}
Here is \PB{\\{main}(\,)}.
\Y\B\&{int} \\{main}(\&{void})\1\1 $\{{}$\7
\X20:Initialize the inputs and capture mode\X\X17:Initialize pin outputs\X\par
\fi

\M{9}
Of course, any interrupt function requires that bit ``Global Interrupt Enable''
is set; usually done through calling sei().
\Y\B\\{sei}(\,);\par
\fi

\M{10}
Rather than burning loops, waiting 18~ms for something to happen, the ``sleep''
mode is used.
The specific type of sleep is `idle'. In idle, execution stops but timers
continue.
Interrupts are used to wake it.
\Y\B\X18:Configure to idle on sleep\X\\{ledcntl}(\.{OFF});\6
${}\.{ADMUX}\MRL{{\OR}{\K}}(\CM(\T{1}\LL\.{MUX2})\OR\CM(\T{1}\LL\.{MUX1})\OR%
\CM(\T{1}\LL\.{MUX0})){}$;\SHC{ Set to channel 0 }\par
\fi

\M{11}
This is the loop that does the work. It should spend most of its time in \PB{%
\\{sleep\_mode}}, comming out at each interrupt event caused by an edge.

\Y\B\&{for} ( ;  ; \,)\SHC{ forever }\6
$\{{}$\Y\par
\fi

\M{12}
Now we wait in ``idle''.
\Y\B\\{sleep\_mode}(\,);\par
\fi

\M{13}
If execution arrives here, some interrupt has been detected.
\Y\B\&{static} \&{char} \\{toggle}${}\K\T{0};{}$\7
${}\{{}$\1\6
\&{if} (\\{toggle})\5
${}\{{}$\1\6
\\{ledcntl}(\.{ON});\6
${}\.{TCCR1B}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ICES1}){}$;\SHC{ wait for falling
edge }\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{ledcntl}(\.{OFF});\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICES1}){}$;\SHC{wait for rising edge }\6
\4${}\}{}$\2\6
${}\\{toggle}\K\\{toggle}\?\T{0}:\T{1};{}$\6
\4${}\}{}$\2\7
$\}{}$\SHC{ end for }\7
\&{return} \T{0};\SHC{ it's the right thing to do! }\7
$\}{}$\SHC{ end main() }\par
\fi

\M{14}
Here is a simple function to flip the LED on or off.
\Y\B\&{void} \\{ledcntl}(\\{uint8\_t}\\{state})\1\1\2\2\6
${}\{{}$\1\6
${}\.{PORTB}\K\\{state}\?\.{PORTB}\OR(\T{1}\LL\.{PORTB5}):\.{PORTB}\AND\CM(%
\T{1}\LL\.{PORTB5});{}$\6
\4${}\}{}$\2\par
\fi

\M{15}

\fi

\N{1}{16}These are the supporting routines, procedures and configuration
blocks.


Here is the block that sets-up the digital I/O pins.
\fi

\M{17}\B\X17:Initialize pin outputs\X${}\E{}$\6
${}\{{}$\C{ set the led port direction; This is pin \#13 }\1\6
${}\.{DDRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{DDB5});{}$\6
\4${}\}{}$\2\par
\U8.\fi

\M{18}\B\X18:Configure to idle on sleep\X${}\E{}$\6
${}\{{}$\1\6
${}\.{SMCR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{SM2});{}$\6
${}\.{SMCR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{SM1});{}$\6
${}\.{SMCR}\MRL{\AND{\K}}\CM(\T{1}\LL\.{SM0});{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{19}
To enable this interrupt, set the ACIE bit of register ACSR.
\fi

\M{20}\B\X20:Initialize the inputs and capture mode\X${}\E{}$\6
${}\{{}$\1\6
${}\.{ADCSRB}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACME}){}$;\SHC{ Conn the MUX to (-)
input of comparator }\6
${}\.{ADMUX}\MRL{{\OR}{\K}}(\T{1}\LL\.{MUX0}){}$;\SHC{ Set bit MUX0 of register
ADMUX }\6
${}\.{ADCSRA}\MRL{\AND{\K}}\CM(\T{1}\LL\.{ADEN}){}$;\SHC{ Turn off ADC to use
its MUX (per 23.2) }\6
${}\.{DIDR0}\MRL{{\OR}{\K}}((\T{1}\LL\.{AIN1D})\OR(\T{1}\LL\.{AIN0D})){}$;\SHC{
Disable digital inputs }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACBG}){}$;\SHC{ Connect the + input to
the band-gap reference }\6
${}\.{ACSR}\MRL{{\OR}{\K}}(\T{1}\LL\.{ACIC}){}$;\SHC{ Enable input capture mode
}\6
${}\.{TIMSK1}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICIE1}){}$;\SHC{ Enable input capture
interrupt }\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{ICNC1}){}$;\SHC{ Enable input capture
noise canceling }\6
${}\.{TCCR1B}\MRL{{\OR}{\K}}(\T{1}\LL\.{CS10}){}$;\SHC{ No Prescale. Just count
the main clock }\6
\4${}\}{}$\2\par

\U8.\fi


\inx
\fin
\con
